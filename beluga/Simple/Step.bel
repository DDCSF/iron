
% ------------------------------------------------------------------------------
% Single-step evaluation.
step : exp -> exp -> type.

step_app1
  : step X1 X1'
  -> step (app X1 X2) (app X1' X2).

step_app2
  : value X1
  -> step X2 X2'
  -> step (app X1 X2) (app X1 X2').

step_app3
  : value X2
  -> step (app (lam T (\x. X1 x)) X2)  (X1 X2).


% ------------------------------------------------------------------------------
% Lemma: Values can't step.
rec nostep_value 
  : [.step X X'] -> [.value X] -> [.false]
  = fn s => fn v
  => case v of
    | [.vlam] => impossible s in [];


% Lemma: Small step evaluation is deterministic.
step_split      : exp -> exp -> exp -> type.
step_split_pair : step X X1 -> step X X2 -> step_split X X1 X2.

rec step_det_split
  : [.step_split X X1 X2] -> [.eqx X1 X2]
  = fn s 
  => case s of
    | [. step_split_pair (step_app1 S1) (step_app1 S2) ]
    => let [.eqx_refl] = step_det_split [.step_split_pair S1 S2] in [.eqx_refl]
  
    | [. step_split_pair (step_app2 _ S1) (step_app2 _ S2) ]
    => let [.eqx_refl] = step_det_split [.step_split_pair S1 S2] in [.eqx_refl]

    | [. step_split_pair (step_app3 _)  (step_app3 _) ]
    => [. eqx_refl]

    % -- Impossible cases.
    | [. step_split_pair (step_app1 S1)   (step_app2 V S2) ]
    => impossible nostep_value [.S1] [.V]    in []

    | [. step_split_pair (step_app1 S1)   (step_app3 _) ]
    => impossible nostep_value [.S1] [.vlam] in []

    | [. step_split_pair (step_app2 V _) (step_app1 S2) ]
    => impossible nostep_value [.S2] [.V]    in []

    | [. step_split_pair (step_app2 V S1) (step_app3 V) ]  
    => impossible nostep_value [.S1] [.V]    in []

    | [. step_split_pair (step_app3 _)    (step_app1 S2) ]
    => impossible nostep_value [.S2] [.vlam] in []

    | [. step_split_pair (step_app3 V)   (step_app2 V S2) ]
    => impossible nostep_value [.S2] [.V]    in []

    | [. step_split_pair (step_app3 _)    (step_app1 S2) ]
    => impossible nostep_value [.S2] [.vlam] in [];


% Progress ---------------------------------------------------------------------
result : exp -> type.
rval   : value X   -> result X.
rstep  : step X X' -> result X.

rec progress
  : [.typex X T] -> [.result X]
  = fn d
  => case d of
    | [.typex_lam D]
    => [.rval vlam]

    | [.typex_app D1 D2]
    => case progress [.D1] of
      | [.rstep S1]   => [.rstep (step_app1 S1)] 
      | [.rval  vlam] 
      => case progress [.D2] of
        | [.rstep S2] => [.rstep (step_app2 vlam S2)]
        | [.rval V2]  => [.rstep (step_app3 V2)];


% Preservation -----------------------------------------------------------------
rec preservation
  : [.typex X T] -> [.step X X'] -> [.typex X' T]
  = fn d => fn s 
  => case s of
    | [.step_app1 S1]
    => let [.typex_app D1 D2] = d in
      let [.D1']             = preservation [.D1] [.S1] 
      in  [.typex_app D1' D2 ]

    | [. step_app2 V S2]
    => let [.typex_app D1 D2] = d in
      let [.D2' ]            = preservation [.D2] [.S2]
      in  [.typex_app D1 D2']

    | [.step_app3 V]
    => let [.typex_app (typex_lam (\x. (\d. D1 x d))) D2] = d 
      in  [.D1 _ D2 ];
