
% Single step evaluation.
step : exp -> exp -> type.

step_app1 
  : step X1 X1'
  -> step (app X1 X2) (app X1' X2).

step_app2 
  : value X1
  -> step X2 X2'
  -> step (app X1 X2) (app X1 X2').

step_app3
  : value X2
  -> step (app (lam T (\x. X1 x)) X2)  (X1 X2).


% Progress -----------------------------------------------------------
result : exp -> type.
rval   : value X   -> result X.
rstep  : step X X' -> result X.

rec progress
  : [.typex X T] -> [.result X]
  = fn d
  => case d of
    | [.typex_lam D]
    => [.rval vlam]

    | [.typex_app D1 D2]
    => case progress [.D1] of
      | [.rstep S1]   => [.rstep (step_app1 S1)] 
      | [.rval  vlam] 
      => case progress [.D2] of
        | [.rstep S2] => [.rstep (step_app2 vlam S2)]
        | [.rval V2]  => [.rstep (step_app3 V2)];


% Preservation -------------------------------------------------------
rec preservation
  : [.typex X T] -> [.step X X'] -> [.typex X' T]
  = fn d => fn s 
  => case s of
    | [.step_app1 S1]
    => let [.typex_app D1 D2] = d in
      let [.D1']             = preservation [.D1] [.S1] 
      in  [.typex_app D1' D2 ]

    | [. step_app2 V S2]
    => let [.typex_app D1 D2] = d in
      let [.D2' ]            = preservation [.D2] [.S2]
      in  [.typex_app D1 D2']

    | [.step_app3 V]
    => let [.typex_app (typex_lam (\x. (\d. D1 x d))) D2] = d 
      in  [.D1 _ D2 ];
