
tm : type.
lam : (tm -> tm) -> tm.
app : tm -> tm -> tm.

schema ctx = tm;

datatype Clos : ctype 
 = Cl : (g:ctx) [g,x:tm . tm] -> ([g . tm] -> Clos) -> Clos;

rec reduce : (g:ctx) [g.tm] -> ([g.tm] -> Clos) -> Clos
 = fn e => fn env 
 => case e of
   % Match a variable in context 'g'
   | [g. #p ..]            => env [g.#p..]

   % Build a closure for a lambda abstraction.
   | [g. lam (\x. E .. x)] => Cl  [g, x:tm . E .. x] env

   % 
   | [g. app (E1 ..) (E2 ..)]
   => case reduce [g. E1 ..] env of
     | Cl [h, x:tm . E .. x] env'
     => let v = reduce [g. E2 ..] env 
       in  reduce [h, x:tm. E .. x]
                  (fn var => case var of
                    | [h, x : tm. x] => v
                    | [h, x : tm. #p ..] => env' [h . #p ..]);


       


%{
rec eval : (g:tctx) [g . tm] -> ([g.tm] -> Clos) -> Clos =
fn e => fn env => case e of
| [g . #p .. ] => env [g . #p ..]
| [g . lam \x. E .. x] => Cl [g, x:tm . E .. x] env
| [g . app (E1 ..) (E2 ..)] =>
  case eval [g . E1 ..] env of
  | Cl [h, x:tm . E .. x] env' =>
    let v = eval [g . E2 ..] env in
    eval [h,x:tm . E .. x]
         (fn var => case var of
               | [h, x:tm . x] => v
               | [h, x:tm . #p .. ] => env' [h . #p ..]
         )

;
%}
