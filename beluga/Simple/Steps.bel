
% ------------------------------------------------------------------------------
% Multi-step evaluation with append.
%  This version has an append constructor, which we use when converting a
%  a big-step evaluation to the small-step version.

steps  : exp -> exp -> type.

steps_none
  : steps X X.

steps_cons
  : step X1 X2 -> steps X2 X3
  -> steps X1 X3.

steps_append
  : steps X1 X2 -> steps X2 X3
  -> steps X1 X3.


% ------------------------------------------------------------------------------
% Left-linearised multi-step evaluation.
%  This version provides a single step at a time and does not have an
%  append constructor. This is convenient when converting a small-step
%  evaluations to big-step, via the eval_expansion lemma.

stepsl : exp -> exp -> type.

stepsl_none 
  : stepsl X X.

stepsl_cons
  : step X1 X2 -> stepsl X2 X3
  -> stepsl X1 X3.


% Lemma: Transitivity of left linearised multi-step evaluation.
rec stepsl_trans 
  : [.stepsl X1 X2] -> [.stepsl X2 X3] -> [.stepsl X1 X3]
  = fn ss1 => fn ss2 
  => case ss1 of
    | [.stepsl_none] 
    => let [.SS2] = ss2 in [.SS2]

    | [.stepsl_cons S1 SS2]
    => stepsl_trans 
            (stepsl_trans [.stepsl_cons S1 stepsl_none] [.SS2]) 
            ss2;


% ------------------------------------------------------------------------------
% Lemma: Linearise a multi-step evaluation.
%  This flattens out all the append constructors, leaving us with a list of
%  individual single step transitions.

rec stepsl_from_steps
  : [.steps X1 X2] -> [.stepsl X1 X2]
  = fn s1 
  => case s1 of
    | [.steps_none] 
    => [.stepsl_none]

    | [.steps_cons S1 SS1]
    => let [.SL1] = stepsl_from_steps [.SS1]
      in  [.stepsl_cons S1 SL1]
 
    | [.steps_append SS1 SS2]
    => let [.SL1] = stepsl_from_steps [.SS1] in
      let [.SL2] = stepsl_from_steps [.SS2]
      in  stepsl_trans [.SL1] [.SL2];
